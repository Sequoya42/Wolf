/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   draw.c                                             :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: rbaum <rbaum@student.42.fr>                +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2015/05/31 14:52:53 by rbaum             #+#    #+#             */
/*   Updated: 2015/05/31 14:52:57 by rbaum            ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "wolf.h"

t_color		cren(double y, t_color s, t_color c)
{
	double	cren;
	t_color	f;

	cren = (y - (double)(int)y);
	cren *= 100;
	f.r = (s.r * (cren) / 100) + ((c.r * (100 - cren)) / 100);
	f.g = (s.g * (cren) / 100) + ((c.g * (100 - cren)) / 100);
	f.b = (s.b * (cren) / 100) + ((c.b * (100 - cren)) / 100);
	return (f);
}

void		draw_ceiling(t_wolf *t, t_color c, double y, int x)
{
	double 	i;
	t_color	s;
	t_color	f;

	i = 0;
	s = set_color(44, 47, 94);
	while (i < y - 1)
	{
		 t->p[(x + ((int)i * 800))] = couleur(s.r, s.g, s.b, 100);
		i++;
	}
	f = cren(y, s, c);
	t->p[(x + ((int)i * 800))] = couleur(f.r, f.g, f.b, 100);
}

void		draw_walls(t_wolf *t, t_color c, int x, double wh)
{
	t_color f;
	t_color s;
	double z;
	double y;

	s = set_color(0, 112, 0);
	z = ((HEIGHT / 2) + (wh / 2));
	y = (HEIGHT / 2) - ((int)wh / 2);
	y = (y < 0) ? 0 : y;
	(void)c;
	while (y < 800 && y < z - 2)
	{
		t->p[(x + ((int)y * 800))] = couleur(c.r , c.g, c.b, 100);
		y++;
	}
	f = cren(z, c, s);
	t->p[(x + ((int)y * 800))] = couleur(f.r, f.g, f.b, 100);
}

void		draw_floor(t_wolf *t, t_color c, int x, double z, double wh)
{
	t_color s;
	t_color f;
	t_color	tmp;

	(void)c;
	tmp = set_color(0,255,255);
	if (t->neon == 1)
	{
		s = set_color(0, 112, 0);
		f = cren(z, c, tmp);
		t->p[(x + ((int)z * 800))] = couleur(f.r, f.g, f.b, 100);
		z++;
		t->p[(x + ((int)z * 800))] = couleur(tmp.r, tmp.g, tmp.b, 100);
		z++;
		f = cren(z, tmp, s);
		t->p[(x + ((int)z * 800))] = couleur(f.r, f.g, f.b, 100);
		z++;
	}
	s = shad(s, wh);
	(void)wh;
	while (z < 800)
	{
		t->p[(x + ((int)z * 800))] = couleur(s.r, s.g, s.b, 100);
		z++;
	}

}
void		draw_ray(double dx, double dy, int x, t_wolf *t)
{
	t_color	c;
	double	wh;
	double 	y;
	double	z;

	c = choose_color(dx, dy, t);
	wh = (dx < dy) ? dx : dy;
	c = shad(c, wh);
	wh = (WALL / wh) * DIST;
	y = (HEIGHT / 2) - (wh / 2);
	z = ((HEIGHT / 2) + (wh / 2));
	draw_ceiling(t, c, y, x);
	draw_walls(t, c, x , wh);
	if (z < WIDTH)
		draw_floor(t, c, x, z, wh);
}/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   events.c                                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: rbaum <rbaum@student->42.fr>                +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2015/05/15 18:51:17 by rbaum             #+#    #+#             */
/*   Updated: 2015/05/15 18:51:17 by rbaum            ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "wolf.h"

void		rotate(t_wolf *t)
{
	if (t->keystate[SDL_SCANCODE_RIGHT])
	{
		ANG -= 2.1;
		while (ANG < 0)
			ANG += 360;
	}
	else if (t->keystate[SDL_SCANCODE_LEFT])
	{
		ANG += 2.1;
		while (ANG >= 360)
			ANG -= 360;
	}
	if (t->keystate[SDL_SCANCODE_W] && t->height < 1000)
		t->height += 5;
	if (t->keystate[SDL_SCANCODE_Q] && t->height > 200)
		t->height -= 5;
}

void		look_away(t_wolf *t)
{
	if (KEY == SDLK_n)
		t->neon = (t->neon == 0) ? 1 : 0;
}

void		move(t_wolf *t, int ix, int iy)
{

	if (t->keystate[SDL_SCANCODE_UP])
	{
		if (t->map[((int)POSY / 64)][PX] != 1)
			POSX += ix;
		if (t->map[PY][((int)POSX / 64)] != 1)
			POSY -= iy;
	}
	else if (t->keystate[SDL_SCANCODE_DOWN])
	{
		if (t->map[((int)POSY / 64)][PX2] != 1)
			POSX -= ix;
		if (t->map[PY2][((int)POSX / 64)] != 1)
			POSY += iy;
	}
}

void		teleport(t_wolf *t)
{
	int x;
	int y;

	if (KEY == SDLK_p)
	{
		while (1)
		{
			POSX = rand() % MW * 64;
			POSY = rand() % MH * 64;
			y = (int)(POSX / WALL);
			x = (int)(POSY / WALL);
		if (t->map[x][y] == 0
			&& (t->map[x + 1][y + 1] == 0)
			&& (t->map[x + 1][y] == 0)
			&& (t->map[x][y + 1] == 0)
			&& (t->map[x - 1][y - 1] == 0)
			&& (t->map[x - 1][y] == 0)
			&& (t->map[x][y - 1] == 0)
			&& (t->map[x + 1][y - 1] == 0)
			&& (t->map[x - 1][y + 1] == 0))
			break;
		}
		printf("x: %d\t\ty: %d\n", x, y);
	}
}
void		trip(t_wolf *t)
{
	teleport(t);
	if (KEY == SDLK_t)
		t->trip = (t->trip == 0) ? 1 : 0;
	if (KEY == SDLK_c)
		t->choose = (t->choose == 0) ? 1 : 0;
}

void		key_events(t_wolf *t)
{
	if (t->event.type == SDL_KEYDOWN)
	{
		if (KEY == 27)
		{
			SDL_DestroyWindow(t->window);
			SDL_Quit();
			exit(1);
		}
		trip(t);
		look_away(t);
	}
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   get_map.c                                          :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: rbaum <rbaum@student->42.fr>                +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2015/04/29 13:08:33 by rbaum             #+#    #+#             */
/*   Updated: 2015/05/14 20:23:22 by rbaum            ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "wolf.h"

void	init_map(t_wolf *t)
{
	int i;

	i = 0;
	if ((t->map = malloc(sizeof(int *) * (MH + 1))) == NULL)
		return ;
	while (i <= MH)
	{
		if ((t->map[i] = malloc(sizeof(int) * (MW + 1))) == NULL)
			return ;
		i++;
	}
	
}

int		get_length(char *m, t_wolf *t)
{
	int		fd;
	int		z;
	char	*line;
	
	MH = 0;
	MW = 0;
	if ((fd = open(m, O_RDONLY)) == -1)
		return (ft_error(NULL, NULL, "Failed to open"));
	while (get_next_line(fd, &line))
	{
		z = 0;
		while (line[z++])
			MW++;
		MH++;
		free(line);
	}
	close(fd);
	free(line);
	MW /= MH;
	init_map(t);
	return (1);
}

void		read_map(char *m, t_wolf *t)
{
	int		fd;
	int		y;
	int		x;
	int		i;
	char	*line;
	
	y = 0;
	x = 0;
	fd = open(m, O_RDONLY);
	while (get_next_line(fd, &line))
	{
		i = 0;
		while (line[i])
		{
			t->map[y][x] = line[i] - 48;
			x++;
			i++;
		}
		free(line);
		y++;
		x = 0;
	}
	free(line);
	close(fd);
}

int		get_map(char *s, t_wolf *t)
{
	s = "maps/map01";//Remove to choose map
	if (get_length(s, t) == -1)
		return (-1);
	read_map(s, t);
	POSX = ((int)WALL * MW / 2);
	POSY = ((int)WALL * MH / 2);
	return (0);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   main.c                                             :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: rbaum <rbaum@student.42.fr>                +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2015/04/26 19:19:29 by rbaum             #+#    #+#             */
/*   Updated: 2015/05/14 20:24:12 by rbaum            ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "wolf.h"

int			main(int ac, char **av)
{
	t_wolf	t;

	if (ac < 1)//Change to two to change maps
		return (0);
	if ((ft_init(&t)) == -1)
		return (-1);
	if (get_map(av[1], &t) == -1)
		return (-1);
	running(&t);
	return 0;
}

int		ft_init(t_wolf *t)
{
	ANG = 90.4;
	t->trip = 0;
	t->choose = 0;
	t->dist = 400;
	t->neon = 0;
	t->height = 600;
	srand(time(NULL));
	if ((SDL_Init(SDL_INIT_EVERYTHING)) == -1)
		return (ft_error(NULL, NULL, "Cannot init SDL"));
	t->window = SDL_CreateWindow
	("test", 500, 300, WIDTH, HEIGHT, 0);
	t->renderer = SDL_CreateRenderer(t->window, -1, 
		SDL_RENDERER_ACCELERATED);
	SDL_RenderSetLogicalSize(t->renderer, WIDTH, HEIGHT);
	create_new_renderer(t);
	return (0);
}

void		running(t_wolf *t)
{
	unsigned int	ti;
	unsigned int	dif;
	int inc;
	int	ix;
	int	iy;

	inc = 8;
	t->keystate = SDL_GetKeyboardState(NULL);
	while (1)
	{
		ti = SDL_GetTicks();
		ix = cos(ANG D) * inc;
		iy = sin(ANG D) * inc;
		while (SDL_PollEvent(&t->event))
			key_events(t);
		move(t, ix, iy);
		rotate(t);
		raycast(t);
		dif = (SDL_GetTicks() - ti);
		if (dif < 20)
			SDL_Delay(20 - dif);
	}
}/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   raycast->c                                          :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: rbaum <rbaum@student->42.fr>                +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2015/05/16 17:52:30 by rbaum             #+#    #+#             */
/*   Updated: 2015/05/19 22:28:22 by rbaum            ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "wolf.h"

static double		raycast_horizontal(double tang, t_wolf *t)
{
	double			y;
	double			x;
	double			ya;
	double			xa;
	double			dx;

	int tx = (int)POSX;
	int ty = (int)POSY;
	ya = (ALPHA > 180.0) ? 64.0 : -64.0;
	xa = - ya / tang;
	y = (double)(ty - ((int)ty % 64));
	y = (ALPHA < 180.0) ? y - 0.0001 : y + 64.0;
	x = tx + ((ty - y) / tang);
	while (SAFE && VALUE != 1)
	{
		x += xa;
		y += ya;
	}
	dx = fabs(((tx - x) / cos(ALPHA  D)));
	dx *= (cos(((ALPHA - ANG) D)));
	return (dx);
}

static double		raycast_vertical(double tang, t_wolf *t)
{
	double 			x;
	double			y;
	double			xa;
	double			ya;
	double			dy;

	int	tx = (int)POSX;
	int	ty = (int)POSY;
	xa = (ALPHA > 90.0 && ALPHA < 270.0) ? -64.0 :  64.0;
	ya = - xa * tang;
	x = (double)(tx - ((int)tx % 64));
	x = (ALPHA < 90.0 || ALPHA > 270.0) ? x + 64.0 : x - 0.0001;
	y = ty + ((tx - x) * tang);
	while (SAFE && VALUE != 1)
	{
		x += xa;
		y += ya;
	}
	dy = fabs(((tx - x) / cos(ALPHA D)));
	dy *= (cos(((ALPHA - ANG)) D));
	return (dy);
}

void				raycast(t_wolf *t)
{
	int				i;
	double			h;
	double			v;
	double			arc;
	double			tang;

	i = WIDTH;
	arc = 0.075;
	ALPHA = ANG - 30.0;
	tang = (double)tan(ALPHA D);
	while (i >= 0)
	{
		h = raycast_horizontal(tang, t);
		v = raycast_vertical(tang, t);
		draw_ray(h, v, i, t);
		ALPHA += arc;
		ALPHA = (ALPHA >= 360) ? ALPHA - 360 : ALPHA;
		ALPHA = (ALPHA < 0) ? ALPHA + 360 : ALPHA;
		tang = (double)tan(ALPHA D);
		i--;
	}
	SDL_UpdateTexture(t->screen, NULL, t->p, WIDTH * sizeof(Uint32));
	SDL_RenderCopy(t->renderer, t->screen, NULL, NULL);
	SDL_RenderPresent(t->renderer);
	ft_bzero(t->p, sizeof(Uint32) * WIDTH * HEIGHT);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   short_func.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: rbaum <rbaum@student->42.fr>                +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2015/05/16 17:56:09 by rbaum             #+#    #+#             */
/*   Updated: 2015/05/16 17:56:13 by rbaum            ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "wolf.h"

t_color		set_color(char r, char g, char b)
{
	t_color		c;

	c.r = r;
	c.g = g;
	c.b = b;
	return (c);
}


Uint32 couleur(int r, int g, int b, int m)
{ 
	while (m > 255)
		m -= 255;
	return (((((r << 8) + g) << 8)+ b) * m / 100);
}

int			shade(t_wolf *t, double wh)
{
	int m;

	if (t->trip == 1)
		m = wh;
	else
		m = 100;
		return (m);
}

t_color		choose_color(double dx, double dy, t_wolf *t)
{
	t_color c;
	if (dx < dy && ALPHA >= 0 && ALPHA < 180)
		c = set_color(138, 111 , 226);//blue violet
	else if (dx < dy && ALPHA >= 180 && ALPHA < 360)
		c = set_color(165, 42, 42); // brown red
	else if (dy < dx && ALPHA >= 90  && ALPHA < 270)
		c = set_color(205, 117, 0); // gold 3
	else
		c = set_color(0, 102, 124);// mellow blue
	return (c);

}

void		create_new_renderer(t_wolf *t)
{
	t->p = (Uint32 *)malloc(sizeof(Uint32) * WIDTH * HEIGHT);
	t->screen = SDL_CreateTexture(t->renderer, SDL_PIXELFORMAT_ARGB8888,
		SDL_TEXTUREACCESS_STREAMING, WIDTH, HEIGHT);
}

t_color shad(t_color c, double dist)
{
	if (dist > MAX_DISTANCE)
	return (set_color(0, 0, 0));
	c.r = (unsigned char)((double)c.r * (1.0 - (dist / MAX_DISTANCE)));
	c.g = (unsigned char)((double)c.g * (1.0 - (dist / MAX_DISTANCE)));
	c.b = (unsigned char)((double)c.b * (1.0 - (dist / MAX_DISTANCE)));
	return (c);
}/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   vector.c                                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: rbaum <rbaum@student->42.fr>               +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2015/04/26 19:09:40 by rbaum             #+#    #+#             */
/*   Updated: 2015/05/14 20:28:06 by rbaum            ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "wolf.h"

void			vector(t_wolf *t)
{
	t->trip = 0;
}